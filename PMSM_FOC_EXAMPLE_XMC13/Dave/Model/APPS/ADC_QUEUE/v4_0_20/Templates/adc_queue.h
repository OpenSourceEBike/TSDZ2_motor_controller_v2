/**
 * @file adc_queue.h
 * @date 2016-08-18
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * ADC_QUEUE v4.0.20 - Provides configurations for queue request source of VADC
 *
 * Copyright (c) 2015-2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version for DAVEv4.<BR>
 *
 * 2015-04-27:
 *     - Optimized the ADC_QUEUE_AllEntriesInserted.<BR>
 *
 * 2015-06-20:
 *     - Updated the copyright section.<BR>
 *
 * 2015-06-26:
 *     - Added flushing of all the queue entries before inserting to the Hardware buffer.<BR>
 *
 * 2015-07-09:
 *     - Documentation updated.<BR>
 *
 * 2015-07-31:
 *     - Updated the APP to support new devices.<BR>
 *
 * 2015-10-01:
 *     - Iclass signal added to the APP.<BR>
 *
 * 2015-10-08:
 *     - Added support for XMC4700/XMC4800 devices.<BR>
 *
 * 2015-12-15:
 *          - Added support for XMC4300 devices.<BR>
 *          - Updated the APP to optimize the request source callback.<BR>
 *          - APIs touched are ADC_QUEUE_InsertQueueEntry(), ADC_QUEUE_ResetListContents(),
 *            ADC_QUEUE_ReqSrcEventHandler().<BR>
 *
 * 2016-01-19:
 *          - Added new APIs ADC_QUEUE_EnableArbitration() and ADC_QUEUE_DisableArbitration().<BR>
 *
 * 2016-04-03:
 *          - Total conversion time now includes post calibration time as well for XMC1x.<BR>
 *
 * 2016-08-18:
 *     - Minimum sample time at low frequencies changed to incorporate Errata ADC_AI.H006 and ADC_AI.H007.
 *
 * @endcond
 *
 */


/*CODE_BLOCK_BEGIN*/
#ifndef ADC_QUEUE_H
#define ADC_QUEUE_H

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/

#include "GLOBAL_ADC/global_adc.h"
#include "adc_queue_conf.h"

 /**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
 
 #if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 0U) && \
       (XMC_LIB_PATCH_VERSION >= 0U)))
#error "ADC_QUEUE requires XMC Peripheral Library v2.0.0 or higher"
#endif

/**
 * @ingroup ADC_QUEUE_constants
 * @{
 */
#define ADC_QUEUE_NUM_CHANNELS XMC_VADC_NUM_CHANNELS_PER_GROUP /**< Number of adc channels per group */

#define ADC_QUEUE_NUM_GROUPS   XMC_VADC_MAXIMUM_NUM_GROUPS  /**< number of groups present */

#define ADC_QUEUE_NUM_LISTS    (2U)  /**< There are 2 lists present in the ADC_QUEUE APP.
                                       One for holding the entries in the channel order.
                                       The other to hold the lists in the order of the positions.
                                       This Macro is used in order of create Lists.*/

#define ADC_QUEUE_CH_INDEX  (0) /**<This Macro defines the location in the List where the ADC_QUEUE Entry should be added.
                    .Used in the list which orders the entries according to the channel numbers.*/

#define ADC_QUEUE_POS_INDEX  (1U) /**< This Macro defines the location in the List where the ADC_QUEUE Entry should be
                    added.  Used in the list which orders the entries according to the
                    position of channel in the queue.*/

typedef void (*ADC_QUEUE_EVENT_CALLBACK)(void);  /**< The callback function pointer, for when a request source Interrupt or
                           channel event occurs. */
/**
 * @}
 */


/**********************************************************************************************************************
* ENUMS
**********************************************************************************************************************/
/**
 * @ingroup ADC_QUEUE_enumerations
 * @{
 */

/**
 * @brief Return value of an API
 */
typedef enum ADC_QUEUE_STATUS
{
  ADC_QUEUE_SUCCESS = 0, /**< App is initialized */
  ADC_QUEUE_FAILURE,       /**< App initialization failed*/
  ADC_QUEUE_UNINITIALIZED   /**< App is not initialized */
} ADC_QUEUE_STATUS_t;

/**
 * @}
 */
/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
/** 
 * @ingroup ADC_QUEUE_datastructures
 * @{
 */

/**
 * @brief Structure holding information on a new queue entry.
 */
typedef struct ADC_QUEUE_ENTRY
{
  ADC_QUEUE_EVENT_CALLBACK adc_event_callback; /**< The call back function when a request source event
                                                   of a channel event is requested.*/

  uint8_t queue_position;     /**< This indicates the position of the channel in the queue FIFO buffer.*/

  uint8_t channel_number;     /**< This indicates the channel number that must be converted.*/

  bool trigger_needed;      /**< This flag indicates that the conversion of the channel is based on a trigger.*/

  bool refill_needed;       /**< This flag indicates that the queue refill is required or not.*/

  bool ch_event_notification; /**< This flag indicates that the channel event interrupt is required.*/

  bool rs_event_notification; /**< This flag indicates that the request source event interrupt is required.*/
} ADC_QUEUE_ENTRY_t;

/**
 * @brief  NVIC Configuration structure for Queue request source interrupt
 */
typedef struct ADC_QUEUE_ISR
{
  uint32_t node_id;    /**< This indicates the NVIC Node number.*/

  uint32_t priority;   /**< This indicates the NVIC priority.*/

  uint32_t sub_priority; /**< This indicates the NVIC sub priority in XMC4x Devices.*/

  bool interrupt_enable; /**< This flag indicates if a Interrupt has been requested.*/
#ifdef ADC_QUEUE_NON_DEFAULT_IRQ_SOURCE_SELECTED
  uint8_t irqctrl;       /**< This indicates the service request source selected for the consumed NVIC node.*/
#endif
} ADC_QUEUE_ISR_t;

/**
 * @brief Configuration Data structure of ADC_QUEUE APP
 */
typedef struct ADC_QUEUE
{
  const XMC_VADC_GROUP_CLASS_t  iclass_config_handle;       /**< Input Class configuration pointer*/

  const XMC_VADC_QUEUE_CONFIG_t *const queue_config_handle; /**< The pointer to queue configuration structure.*/

  GLOBAL_ADC_t* const global_handle;              /**< Pointer to the associated group app handle.*/

  XMC_VADC_GROUP_t *const group_handle;           /**< This is the pointer to the VADC group Registers.*/

  XMC_VADC_GATEMODE_t gating_mode;                /**< Gating mode configuration needed for Queue request src*/

  const ADC_QUEUE_ISR_t* const rs_intr_handle;    /**< Request source interrupt configuration handle*/

  const XMC_VADC_SR_t srv_req_node;         /**< Source event interrupt node pointer*/

  ADC_QUEUE_STATUS_t init_status;           /**< This holds the state of the ADC_QUEUE APP Instance*/

  const uint8_t instance_number;            /**< APP Instance Number*/

  const uint8_t iclass_num;                 /**< Represents Class to be configured for queue*/

  const uint8_t group_index;                /**< Represents group index number of the queue*/

  uint8_t number_valid_callback;            /**< Index for valid request source callback functions */
} ADC_QUEUE_t;

/**
 * @}
 */

#ifdef __cplusplus
extern "C" {
#endif
/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/**
 * @ingroup ADC_QUEUE_apidoc
 * @{
 */

/**
 * @brief Get ADC_QUEUE APP version
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * Example Usage:
 *
 * @code
 * #include <DAVE.h>
 *
 * int main(void) {
 *   DAVE_STATUS_t init_status;
 *   DAVE_APP_VERSION_t version;
 *
 *   // Initialize ADC_QUEUE APP:
 *   // ADC_QUEUE_Init() is called from within DAVE_Init().
 *   init_status = DAVE_Init();
 *
 *   version = ADC_QUEUE_GetAppVersion();
 *   if (version.major != 1U) {
 *     // Probably, not the right version.
 *   }
 *
 *   // More code here
 *   while(1) {
 *
 *   }
 *   return (0);
 * }
 * @endcode
 */
DAVE_APP_VERSION_t ADC_QUEUE_GetAppVersion(void);

/**
 * @brief Initializes the ADC Queue request source.
 * @param handle_ptr pointer to the Instance variable<BR>
 * @return ADC_QUEUE_STATUS_t status of the initialization.
 *
 * \par<b>Description:</b><br>
 * Initializes the ADC Queue.
 * Invoke various VADC LLD API to initialize the VADC queue request source. This would invoke
 * The GLBOAL_ADC_Init(), if interrupt is consumed for a specific instance it would also invoke
 * CPU_CTRL_XMCx_Init (x = 4 or 1). It also invokes XMC_VADC_GROUP_QueueInit() XMC_VADC_GROUP_QueueSetGatingMode()
 * XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode() to configure the queue source.
 *
 *
 * @code
 *
 * #include <DAVE.h>
 * int main(void)
 * {
 *    DAVE_Init(); //ADC_QUEUE_Init is called within DAVE_Init
 *    while(1);
 *    return 0;
 * }
 @endcode
 */
ADC_QUEUE_STATUS_t ADC_QUEUE_Init(ADC_QUEUE_t *const handle_ptr);

/**
 * @brief Resets the APP data structure which holds the inserted channels.
 * @param instance_num The ADC_QUEUE APP instance Number<BR>
 *                         Range: [0x0 to 0x3]
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Resets the APP data structure which holds the inserted channels.
 * The ADC_QUEUE APP holds an internal data structure (::adc_queue_list_ptrs) which represents the channels being
 * inserted into the hardware. This data structure (::adc_queue_list_ptrs) is sorted in ascending order of channel
 * number and also position number. When the Reset List Contents API is invoked it would clear all the previous
 * contents of this data structure. This resets the data structure such that channel_number is set as
 * INVALID_CHANNEL and all its other fields are 0. ADC_QUEUE_lInitializeListToDefaults() would invoke this
 * API at ADC_QUEUE_Init().
 *
 * \par<b>Note:</b><br>
 * Invoking this API will not effect any channel(s) which have already been pushed to the queue buffer
 * in the hardware.
 *
 *
 * @code
 * //Enable the Request source interrupt in the UI editor of the APP.
  #include <DAVE.h>
  XMC_VADC_RESULT_SIZE_t result[2];

  void adc_callback_ch0(void)
  {
    result[0] = XMC_VADC_GROUP_GetResult(ADC_QUEUE_0.group_handle,1U);
  }

  void adc_callback_ch1(void)
  {
    result[1] = XMC_VADC_GROUP_GetResult(ADC_QUEUE_0.group_handle,2U);
  }

  ADC_QUEUE_ENTRY_t ch_entry0 =
  {
    .queue_position        = 0U,
    .channel_number        = 1U,
    .trigger_needed        = false,
    .refill_needed         = true,
    .ch_event_notification = false,
    .rs_event_notification = true,
    .adc_event_callback    = (adc_callback_ch0)
  };

  ADC_QUEUE_ENTRY_t ch_entry1 =
  {
    .queue_position        = 0U,
    .channel_number        = 2U,
    .trigger_needed        = false,
    .refill_needed         = true,
    .ch_event_notification = false,
    .rs_event_notification = true,
    .adc_event_callback    = (adc_callback_ch1)
  };

  int main(void)
  {
     DAVE_Init(); //ADC_QUEUE_Init is called within DAVE_Init  \n
     ADC_QUEUE_InsertQueueEntry(&ADC_QUEUE_0,&ch_entry0);
     ADC_QUEUE_InsertQueueEntry(&ADC_QUEUE_0,&ch_entry1);
     // 2 entries present in the data structure.\n
     ADC_QUEUE_ResetListContents(ADC_QUEUE_0.instance_number);
     //0 Entries present in the data structure because of the reset.
     while(1);
     return 0;
  }
 @endcode
 */
void ADC_QUEUE_ResetListContents(uint8_t instance_num);

/**
 * @brief  Inserts an queue entry into the local data structure.<BR>
 * @param handle_ptr of type ADC_QUEUE_t to the instance variable. <BR>
 * @param entry Handle pointer of type ADC_QUEUE_ENTRY_t to the queue entry.<BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Inserts an queue entry into the local data structure.
 * The ADC_QUEUE APP holds an internal data structure (::adc_queue_list_ptrs) which represents the channels being
 * inserted into the hardware. This data structure (::adc_queue_list_ptrs) is sorted in ascending order of channel
 * number and also position number. When an insert is called the queue entry would be copied into this data structure.
 * The insert option would populate the data structure in ascending order of queue position and channel number.
 *
 * \par<b>Note:</b><br>
 * Invoking this API will not add a new channel into the queue buffer of the hardware. The operation of
 * adding all the required channel into the hardware would be done using the method ADC_QUEUE_AllEntriesInserted().
 *
 *
 * @code
  //Enable the Request source interrupt in the UI editor of the APP.
  #include <DAVE.h>

  void adc_callback(void);
  XMC_VADC_RESULT_SIZE_t result;

  ADC_QUEUE_ENTRY_t ch_entry0 =
  {
    .queue_position        = 0U,
    .channel_number        = 1U,
    .trigger_needed        = false,
    .refill_needed         = true,
    .ch_event_notification = false,
    .rs_event_notification = true,
    .adc_event_callback    = (adc_callback)
  };

  static XMC_VADC_CHANNEL_CONFIG_t  ch_handle =
  {
    .input_class                = (uint32_t) XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,  // Global ICLASS 0 selected
    .lower_boundary_select   = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
    .upper_boundary_select   = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
    .event_gen_criteria         = (uint32_t) XMC_VADC_CHANNEL_EVGEN_NEVER, //Channel Event disabled
    .sync_conversion           = (uint32_t) 0,                            // Sync feature disabled
    .alternate_reference        = (uint32_t) XMC_VADC_CHANNEL_REF_INTREF,  // Internal reference selected
    .result_reg_number          = (uint32_t) 1,                            // GxRES[1] selected
    .result_alignment           = (uint32_t) XMC_VADC_RESULT_ALIGN_RIGHT,  // Result alignment - Right Aligned
    .broken_wire_detect_channel = (uint32_t) XMC_VADC_CHANNEL_BWDCH_VAGND, // No Broken wire mode select
    .broken_wire_detect    = (uint32_t) 0,                         // No Broken wire detection
    .bfl                        = (uint32_t) 0,                            //No Boundary flag
    .channel_priority           = (uint32_t) 0,  // Lowest Priority-0 selected; channel can also be converted
                                                 // by background request source
    .alias_channel              = (int8_t) -1                              // Alias feature not selected
  };

  XMC_VADC_RESULT_CONFIG_t res_handle =
  {
    .data_reduction_control  = (uint8_t) 0,  // No Accumulation
    .post_processing_mode    = (uint32_t) XMC_VADC_DMM_REDUCTION_MODE,
    .wait_for_read_mode     = (uint32_t) 0,  // Result registers are updated as and when the conversion is finished
    .part_of_fifo           = (uint32_t) 0,  // FIFO has been disabled
    .event_gen_enable       = (uint32_t) 0   // result event generation disabled
  };
  void adc_callback(void)
  {
    result = XMC_VADC_GROUP_GetResult(ADC_QUEUE_0.group_handle, ch_handle.result_reg_number);
  }

  int main(void)
  {

     DAVE_Init(); //ADC_QUEUE_Init is called within DAVE_Init
     ADC_QUEUE_InsertQueueEntry(&ADC_QUEUE_0,&ch_entry0);
     // initialize CHANNEL
     XMC_VADC_GROUP_ChannelInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_entry0.channel_number, &ch_handle);
     // initialize RESULT
     XMC_VADC_GROUP_ResultInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);
     // initialize pin if needed
     ADC_QUEUE_AllEntriesInserted(&ADC_QUEUE_0);
     while(1);
     return 0;
  }
 @endcode
 */
void ADC_QUEUE_InsertQueueEntry(ADC_QUEUE_t *const handle_ptr, const ADC_QUEUE_ENTRY_t *entry);

/**
 * @brief Inserts all queue entries into ADC queue FIFO buffer
 * @param handle_ptr pointer (ADC_QUEUE_t) to the instance variable <BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Inserts all queue entries into ADC queue FIFO buffer(programs the hardware).
 * The ADC_QUEUE APP holds an internal data structure (::adc_queue_list_ptrs) which represents the channels being
 * inserted into the hardware. This data structure (::adc_queue_list_ptrs) is sorted in ascending order of channel
 * number and also position number. When this API is invoked all the queue entries that have been inserted
 * into the data structure will be programmed into the hardware. The ADC queue FIFO buffer is loaded according to
 * the queue_position of the queue entry. Hence from queue position-0 upto queue position-7 the channels would be
 * inserted, if valid channels are present in the data structure.
 *
 * \par<b>Note:</b><br>
 * The number of channels that can be inserted are limited to 8(H/W buffer size).
 *
 *
 * @code
  //Enable the Request source interrupt in the UI editor of the APP.
  #include <DAVE.h>

  void adc_callback(void);
  XMC_VADC_RESULT_SIZE_t result[3];

  ADC_QUEUE_ENTRY_t ch_entry0 =
  {
    .queue_position        = 0U,
    .channel_number        = 1U,
    .trigger_needed        = false,
    .refill_needed         = false,
    .ch_event_notification = false,
    .rs_event_notification = false,
    .adc_event_callback    = NULL
  };

  ADC_QUEUE_ENTRY_t ch_entry1 =
  {
    .queue_position        = 1U,
    .channel_number        = 2U,
    .trigger_needed        = false,
    .refill_needed         = false,
    .ch_event_notification = false,
    .rs_event_notification = false,
    .adc_event_callback    = NULL
  };
  ADC_QUEUE_ENTRY_t ch_entry2 =
  {
    .queue_position        = 2U,
    .channel_number        = 3U,
    .trigger_needed        = false,
    .refill_needed         = false,
    .ch_event_notification = false,
    .rs_event_notification = true,
    .adc_event_callback    = (adc_callback)
  };

  static XMC_VADC_CHANNEL_CONFIG_t  ch_handle =
  {
    .input_class                = (uint32_t) XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,  // Global ICLASS 0 selected
    .lower_boundary_select      = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
    .upper_boundary_select      = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
    .event_gen_criteria         = (uint32_t) XMC_VADC_CHANNEL_EVGEN_NEVER, //Channel Event disabled
    .sync_conversion          = (uint32_t) 0,                            // Sync feature disabled
    .alternate_reference        = (uint32_t) XMC_VADC_CHANNEL_REF_INTREF,  // Internal reference selected
    .result_reg_number          = (uint32_t) 1,                            // GxRES[1] selected
    .result_alignment           = (uint32_t) XMC_VADC_RESULT_ALIGN_RIGHT,  // Result alignment - Right Aligned
    .broken_wire_detect_channel = (uint32_t) XMC_VADC_CHANNEL_BWDCH_VAGND, // No Broken wire mode select
    .broken_wire_detect       = (uint32_t) 0,                        // No Broken wire detection
    .bfl                        = (uint32_t) 0,                            //No Boundary flag
    .channel_priority           = (uint32_t) 0,  // Lowest Priority-0 selected; channel can also be converted
                                                 // by background request source
    .alias_channel              = (int8_t) -1                              // Alias feature not selected
  };

  XMC_VADC_RESULT_CONFIG_t res_handle =
  {
    .data_reduction_control  = (uint8_t)  0,  // No Accumulation
    .post_processing_mode    = (uint32_t) XMC_VADC_DMM_REDUCTION_MODE,
    .wait_for_read_mode    = (uint32_t) 0,  // Result registers are updated as and when the conversion is finished
    .part_of_fifo          = (uint32_t) 0,  // FIFO has been disabled
    .event_gen_enable      = (uint32_t) 0   // result event generation disabled
  };


  void adc_callback(void)
  {
  uint8_t result_reg =XMC_VADC_GROUP_ChannelGetResultRegister(ADC_QUEUE_0.group_handle,ch_entry0.channel_number);
  result[0] = XMC_VADC_GROUP_GetResult(ADC_QUEUE_0.group_handle,result_reg);

    result_reg =XMC_VADC_GROUP_ChannelGetResultRegister(ADC_QUEUE_0.group_handle,ch_entry1.channel_number);
  result[1] = XMC_VADC_GROUP_GetResult(ADC_QUEUE_0.group_handle, result_reg);

  result_reg =XMC_VADC_GROUP_ChannelGetResultRegister(ADC_QUEUE_0.group_handle,ch_entry2.channel_number);
    result[2] = XMC_VADC_GROUP_GetResult(ADC_QUEUE_0.group_handle, result_reg);
  }


  int main(void)
  {

     DAVE_Init(); //ADC_QUEUE_Init is called within DAVE_Init
     ADC_QUEUE_InsertQueueEntry(&ADC_QUEUE_0,&ch_entry0);
     // initialize CHANNEL
     XMC_VADC_GROUP_ChannelInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_entry0.channel_number, &ch_handle);
     // initialize RESULT
     XMC_VADC_GROUP_ResultInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);
     // initialize pin if needed

     ADC_QUEUE_InsertQueueEntry(&ADC_QUEUE_0,&ch_entry1);
     ch_handle.result_reg_number = ch_entry1.channel_number;
     // initialize CHANNEL
     XMC_VADC_GROUP_ChannelInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_entry1.channel_number, &ch_handle);
     // initialize RESULT
     XMC_VADC_GROUP_ResultInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);


     ADC_QUEUE_InsertQueueEntry(&ADC_QUEUE_0,&ch_entry2);
     ch_handle.result_reg_number = ch_entry2.channel_number;
     // initialize CHANNEL
     XMC_VADC_GROUP_ChannelInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_entry2.channel_number, &ch_handle);
     // initialize RESULT
     XMC_VADC_GROUP_ResultInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);

     ADC_QUEUE_AllEntriesInserted(&ADC_QUEUE_0);
     while(1);
     return 0;
  }
 @endcode
 */
void ADC_QUEUE_AllEntriesInserted(ADC_QUEUE_t *const handle_ptr);

/**
 * @brief Channel event handler for the queue channels.<BR>
 * @param handle_ptr pointer (ADC_QUEUE_t) to the instance variable <BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Channel event handler for the queue channels.
 * The ADC_QUEUE APP holds an internal data structure (::adc_queue_list_ptrs) which represents the channels being
 * inserted into the hardware. This data structure (::adc_queue_list_ptrs) is sorted in ascending order of channel
 * number and also position number. In each entry it is possible to mention if channel event notification
 * is required. This API will read ::ADC_QUEUE_ENTRY_t::ch_event_notification field of all the queue entries,
 * if a notification is needed then a specific callback is invoked. This callback function is mentioned in the
 * queue entry field ::ADC_QUEUE_ENTRY::adc_event_callback for that channel.
 *
 * \par<b>Note:</b><br>
 * Channel event is not configured by this API. Channel event needs to be configured using a VADC LLD API.
 * If both channel event and request source event needs to be enabled, the field ::ADC_QUEUE_ENTRY_t::adc_event_callback
 * callback function would be invoked from both the handlers(channel event(ADC_QUEUE_ChannelEventHandler())
 * and request source event(ADC_QUEUE_ReqSrcEventHandler())).
 *
 *
 * @code
  #include <DAVE.h>
  #include <xmc_vadc.h>

  void adc_callback(void);
  XMC_VADC_RESULT_SIZE_t result[3];

  ADC_QUEUE_ENTRY_t ch_entry0 =
  {
    .queue_position        = 0U,
    .channel_number        = 1U,
    .trigger_needed        = false,
    .refill_needed         = false,
    .ch_event_notification = true,
    .rs_event_notification = false,
    .adc_event_callback    = (adc_callback)
  };

  static XMC_VADC_CHANNEL_CONFIG_t  ch_handle =
  {
    .input_class                = (uint32_t) XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,  // Global ICLASS 0 selected
    .lower_boundary_select      = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
    .upper_boundary_select      = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
    .event_gen_criteria         = (uint32_t) XMC_VADC_CHANNEL_EVGEN_ALWAYS, //Channel Event disabled
    .sync_conversion          = (uint32_t) 0,                            // Sync feature disabled
    .alternate_reference        = (uint32_t) XMC_VADC_CHANNEL_REF_INTREF,  // Internal reference selected
    .result_reg_number          = (uint32_t) 1,                            // GxRES[1] selected
    .result_alignment           = (uint32_t) XMC_VADC_RESULT_ALIGN_RIGHT,  // Result alignment - Right Aligned
    .broken_wire_detect_channel = (uint32_t) XMC_VADC_CHANNEL_BWDCH_VAGND, // No Broken wire mode select
    .broken_wire_detect       = (uint32_t) 0,                        // No Broken wire detection
    .bfl                        = (uint32_t) 0,                            //No Boundary flag
    .channel_priority           = (uint32_t) 0,  // Lowest Priority-0 selected; channel can also be converted
                                                 // by background request source
    .alias_channel              = (int8_t) -1                              // Alias feature not selected
  };

  XMC_VADC_RESULT_CONFIG_t res_handle =
  {
    .data_reduction_control  = (uint8_t)  0,  // No Accumulation
    .post_processing_mode    = (uint32_t) XMC_VADC_DMM_REDUCTION_MODE,
    .wait_for_read_mode    = (uint32_t) 0,  // Result registers are updated as and when the conversion is finished
    .part_of_fifo          = (uint32_t) 0,  // FIFO has been disabled
    .event_gen_enable      = (uint32_t) 0   // result event generation disabled
  };

  void VADC0_G0_0_IRQHandler(void)
  {
    ADC_QUEUE_ChannelEventHandler(&ADC_QUEUE_0);
  }

  void adc_callback(void)
  {
  uint8_t result_reg =XMC_VADC_GROUP_ChannelGetResultRegister(ADC_QUEUE_0.group_handle,ch_entry0.channel_number);
  result[0] = XMC_VADC_GROUP_GetResult(ADC_QUEUE_0.group_handle,result_reg);
  }


  int main(void)
  {

     DAVE_Init(); //ADC_QUEUE_Init is called within DAVE_Init
     ADC_QUEUE_InsertQueueEntry(&ADC_QUEUE_0,&ch_entry0);
     // initialize CHANNEL
     XMC_VADC_GROUP_ChannelInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_entry0.channel_number, &ch_handle);
     // initialize RESULT
     XMC_VADC_GROUP_ResultInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);
     // initialize pin here if needed

     //Link the channel event to a SR line
     XMC_VADC_GROUP_ChannelSetEventInterruptNode(ADC_QUEUE_0.group_handle, ch_entry0.channel_number,
                                                 XMC_VADC_SR_GROUP_SR0);
   // enable the NVIC node
     NVIC_EnableIRQ(VADC0_G0_0_IRQn);
     ADC_QUEUE_AllEntriesInserted(&ADC_QUEUE_0);
     while(1);
     return 0;
  }
 @endcode
 */
void ADC_QUEUE_ChannelEventHandler(ADC_QUEUE_t *const handle_ptr);

/**
 * @brief Request source event handler for the queue channels.
 * @param handle_ptr pointer (ADC_QUEUE_t) to the instance variable <BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Queue Request source interrupt handler.
 * The ADC_QUEUE APP holds an internal data structure (::adc_queue_list_ptrs) which represents the channels being
 * inserted into the hardware. This data structure (::adc_queue_list_ptrs) is sorted in ascending order of channel
 * number and also position number. In each entry it is possible to mention if request source event notification
 * is required. API will read ::ADC_QUEUE_ENTRY_t::rs_event_notification field of all the queue entries,
 * if a notification is needed then a specific callback is invoked. This callback function is mentioned in the
 * queue entry field ::ADC_QUEUE_ENTRY::adc_event_callback for that channel.
 *
 * \par<b>Note:</b><br>
 * Queue request source event is not configured by this API. Request source event would be configured by the APP
 * using VADC LLD Apis. If both channel event and request source event needs to be enabled, the field
 * ::ADC_QUEUE_ENTRY_t::adc_event_callback callback function would be invoked from both the handlers(channel
 * event(ADC_QUEUE_ChannelEventHandler()) and request source event(ADC_QUEUE_ReqSrcEventHandler())).
 *
 *
 * @code
 * //Enable the Request source interrupt in the UI editor of the APP.
  #include <DAVE.h>

  void adc_callback(void);
  XMC_VADC_RESULT_SIZE_t result[3];

  ADC_QUEUE_ENTRY_t ch_entry0 =
  {
    .queue_position        = 0U,
    .channel_number        = 1U,
    .trigger_needed        = false,
    .refill_needed         = false,
    .ch_event_notification = false,
    .rs_event_notification = true,
    .adc_event_callback    = (adc_callback)
  };

  static XMC_VADC_CHANNEL_CONFIG_t  ch_handle =
  {
    .input_class                = (uint32_t) XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,  // Global ICLASS 0 selected
    .lower_boundary_select      = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
    .upper_boundary_select      = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
    .event_gen_criteria         = (uint32_t) XMC_VADC_CHANNEL_EVGEN_NEVER, //Channel Event disabled
    .sync_conversion          = (uint32_t) 0,                            // Sync feature disabled
    .alternate_reference        = (uint32_t) XMC_VADC_CHANNEL_REF_INTREF,  // Internal reference selected
    .result_reg_number          = (uint32_t) 1,                            // GxRES[1] selected
    .result_alignment           = (uint32_t) XMC_VADC_RESULT_ALIGN_RIGHT,  // Result alignment - Right Aligned
    .broken_wire_detect_channel = (uint32_t) XMC_VADC_CHANNEL_BWDCH_VAGND, // No Broken wire mode select
    .broken_wire_detect       = (uint32_t) 0,                          // No Broken wire detection
    .bfl                        = (uint32_t) 0,                            //No Boundary flag
    .channel_priority           = (uint32_t) 0,  // Lowest Priority-0 selected; channel can also be converted
                                                 // by background request source
    .alias_channel              = (int8_t) -1                              // Alias feature not selected
  };

  XMC_VADC_RESULT_CONFIG_t res_handle =
  {
    .data_reduction_control  = (uint8_t)  0,  // No Accumulation
    .post_processing_mode    = (uint32_t) XMC_VADC_DMM_REDUCTION_MODE,
    .wait_for_read_mode    = (uint32_t) 0,  // Result registers are updated as and when the conversion is finished
    .part_of_fifo          = (uint32_t) 0,  // FIFO has been disabled
    .event_gen_enable      = (uint32_t) 0   // result event generation disabled
  };

  void VADC0_G0_0_IRQHandler(void)
  {
    ADC_QUEUE_ReqSrcEventHandler(&ADC_QUEUE_0);
  }

  void adc_callback(void)
  {
  uint8_t result_reg =XMC_VADC_GROUP_ChannelGetResultRegister(ADC_QUEUE_0.group_handle,ch_entry0.channel_number);
  result[0] = XMC_VADC_GROUP_GetResult(ADC_QUEUE_0.group_handle,result_reg);
  }


  int main(void)
  {

     DAVE_Init(); //ADC_QUEUE_Init is called within DAVE_Init
     ADC_QUEUE_InsertQueueEntry(&ADC_QUEUE_0,&ch_entry0);
     // initialize CHANNEL
     XMC_VADC_GROUP_ChannelInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_entry0.channel_number, &ch_handle);
     // initialize RESULT
     XMC_VADC_GROUP_ResultInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);
     // initialize pin here if needed

     //Link the request source event to a SR line
     XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode(ADC_QUEUE_0.group_handle,XMC_VADC_SR_GROUP_SR0);
     // enable the NVIC node
     NVIC_EnableIRQ(VADC0_G0_0_IRQn);
     ADC_QUEUE_AllEntriesInserted(&ADC_QUEUE_0);
     while(1);
     return 0;
  }
 @endcode
 */
void ADC_QUEUE_ReqSrcEventHandler(ADC_QUEUE_t *const handle_ptr);

/**
 * @brief  Starts the queue request source arbitration.<BR>
 * @param handle_ptr pointer (ADC_QUEUE_t) to the instance variable and the handle pointer.<BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Starts the VADC arbiter for the queue request source.<BR>
 * After this API is invoked the ADC is ready for accepting conversion requests. When invoked this API
 * would write to GxARBPR.ASEN1 bit to enable the arbiter.
 *
 * @code
   //Enable the Request source interrupt in the UI editor of the APP.
  #include <DAVE.h>

  void adc_callback(void);
  XMC_VADC_RESULT_SIZE_t result;

  ADC_QUEUE_ENTRY_t ch_entry0 =
  {
    .queue_position        = 0U,
    .channel_number        = 1U,
    .trigger_needed        = false,
    .refill_needed         = true,
    .ch_event_notification = false,
    .rs_event_notification = true,
    .adc_event_callback    = (adc_callback)
  };

  static XMC_VADC_CHANNEL_CONFIG_t  ch_handle =
  {
    .input_class                = (uint32_t) XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,  // Global ICLASS 0 selected
    .lower_boundary_select   = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
    .upper_boundary_select   = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
    .event_gen_criteria         = (uint32_t) XMC_VADC_CHANNEL_EVGEN_NEVER, //Channel Event disabled
    .sync_conversion           = (uint32_t) 0,                            // Sync feature disabled
    .alternate_reference        = (uint32_t) XMC_VADC_CHANNEL_REF_INTREF,  // Internal reference selected
    .result_reg_number          = (uint32_t) 1,                            // GxRES[1] selected
    .result_alignment           = (uint32_t) XMC_VADC_RESULT_ALIGN_RIGHT,  // Result alignment - Right Aligned
    .broken_wire_detect_channel = (uint32_t) XMC_VADC_CHANNEL_BWDCH_VAGND, // No Broken wire mode select
    .broken_wire_detect    = (uint32_t) 0,                         // No Broken wire detection
    .bfl                        = (uint32_t) 0,                            //No Boundary flag
    .channel_priority           = (uint32_t) 0,  // Lowest Priority-0 selected; channel can also be converted
                                                 // by background request source
    .alias_channel              = (int8_t) -1                              // Alias feature not selected
  };

  XMC_VADC_RESULT_CONFIG_t res_handle =
  {
    .data_reduction_control  = (uint8_t) 0,  // No Accumulation
    .post_processing_mode    = (uint32_t) XMC_VADC_DMM_REDUCTION_MODE,
    .wait_for_read_mode     = (uint32_t) 0,  // Result registers are updated as and when the conversion is finished
    .part_of_fifo           = (uint32_t) 0,  // FIFO has been disabled
    .event_gen_enable       = (uint32_t) 0   // result event generation disabled
  };
  void adc_callback(void)
  {
    result = XMC_VADC_GROUP_GetResult(ADC_QUEUE_0.group_handle, ch_handle.result_reg_number);
  }

  int main(void)
  {

     DAVE_Init(); //ADC_QUEUE_Init is called within DAVE_Init
     ADC_QUEUE_DisableArbitration(&ADC_QUEUE_0);
     ADC_QUEUE_InsertQueueEntry(&ADC_QUEUE_0,&ch_entry0);
     // initialize CHANNEL
     XMC_VADC_GROUP_ChannelInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_entry0.channel_number, &ch_handle);
     // initialize RESULT
     XMC_VADC_GROUP_ResultInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);
     // initialize pin if needed
     ADC_QUEUE_AllEntriesInserted(&ADC_QUEUE_0);
     ADC_QUEUE_EnableArbitration(&ADC_QUEUE_0);
     while(1);
     return 0;
  }
 @endcode
 */
__STATIC_INLINE void ADC_QUEUE_EnableArbitration(ADC_QUEUE_t *const handle_ptr)
{
  XMC_ASSERT("ADC_QUEUE_EnableArbitration:Invalid handle_ptr", (handle_ptr != NULL))

  XMC_VADC_GROUP_QueueEnableArbitrationSlot(handle_ptr->group_handle);
}

/**
 * @brief  Stops the queue request source arbitration.<BR>
 * @param handle_ptr pointer (ADC_QUEUE_t) to the instance variable and the handle pointer.<BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Stops the VADC arbiter for the queue request source.<BR>
 * After this API is invoked the ADC is ready for accepting conversion requests. When invoked this API
 * would write to GxARBPR.ASEN1 bit to disable the arbiter.
 *
 * @code
 * //Enable the Request source interrupt in the UI editor of the APP.
  #include <DAVE.h>

  void adc_callback(void);
  XMC_VADC_RESULT_SIZE_t result;

  ADC_QUEUE_ENTRY_t ch_entry0 =
  {
    .queue_position        = 0U,
    .channel_number        = 1U,
    .trigger_needed        = false,
    .refill_needed         = true,
    .ch_event_notification = false,
    .rs_event_notification = true,
    .adc_event_callback    = (adc_callback)
  };

  static XMC_VADC_CHANNEL_CONFIG_t  ch_handle =
  {
    .input_class                = (uint32_t) XMC_VADC_CHANNEL_CONV_GLOBAL_CLASS0,  // Global ICLASS 0 selected
    .lower_boundary_select   = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
    .upper_boundary_select   = (uint32_t) XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,
    .event_gen_criteria         = (uint32_t) XMC_VADC_CHANNEL_EVGEN_NEVER, //Channel Event disabled
    .sync_conversion           = (uint32_t) 0,                            // Sync feature disabled
    .alternate_reference        = (uint32_t) XMC_VADC_CHANNEL_REF_INTREF,  // Internal reference selected
    .result_reg_number          = (uint32_t) 1,                            // GxRES[1] selected
    .result_alignment           = (uint32_t) XMC_VADC_RESULT_ALIGN_RIGHT,  // Result alignment - Right Aligned
    .broken_wire_detect_channel = (uint32_t) XMC_VADC_CHANNEL_BWDCH_VAGND, // No Broken wire mode select
    .broken_wire_detect    = (uint32_t) 0,                         // No Broken wire detection
    .bfl                        = (uint32_t) 0,                            //No Boundary flag
    .channel_priority           = (uint32_t) 0,  // Lowest Priority-0 selected; channel can also be converted
                                                 // by background request source
    .alias_channel              = (int8_t) -1                              // Alias feature not selected
  };

  XMC_VADC_RESULT_CONFIG_t res_handle =
  {
    .data_reduction_control  = (uint8_t) 0,  // No Accumulation
    .post_processing_mode    = (uint32_t) XMC_VADC_DMM_REDUCTION_MODE,
    .wait_for_read_mode     = (uint32_t) 0,  // Result registers are updated as and when the conversion is finished
    .part_of_fifo           = (uint32_t) 0,  // FIFO has been disabled
    .event_gen_enable       = (uint32_t) 0   // result event generation disabled
  };
  void adc_callback(void)
  {
    result = XMC_VADC_GROUP_GetResult(ADC_QUEUE_0.group_handle, ch_handle.result_reg_number);
  }

  int main(void)
  {

     DAVE_Init(); //ADC_QUEUE_Init is called within DAVE_Init
     ADC_QUEUE_DisableArbitration(&ADC_QUEUE_0);
     ADC_QUEUE_InsertQueueEntry(&ADC_QUEUE_0,&ch_entry0);
     // initialize CHANNEL
     XMC_VADC_GROUP_ChannelInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_entry0.channel_number, &ch_handle);
     // initialize RESULT
     XMC_VADC_GROUP_ResultInit(ADC_QUEUE_0.group_handle, (uint32_t)ch_handle.result_reg_number, &res_handle);
     // initialize pin if needed
     ADC_QUEUE_AllEntriesInserted(&ADC_QUEUE_0);
     ADC_QUEUE_EnableArbitration(&ADC_QUEUE_0);
     while(1);
     return 0;
  }
 @endcode
 */
__STATIC_INLINE void ADC_QUEUE_DisableArbitration(ADC_QUEUE_t *const handle_ptr)
{
  XMC_ASSERT("ADC_QUEUE_DisableArbitration:Invalid handle_ptr", (handle_ptr != NULL))

  XMC_VADC_GROUP_QueueDisableArbitrationSlot(handle_ptr->group_handle);
}


/**
 * @}
 */
#include "ADC_QUEUE_Extern.h"
#ifdef __cplusplus
}
#endif
 
#endif /* ADC_QUEUE_H_ */

