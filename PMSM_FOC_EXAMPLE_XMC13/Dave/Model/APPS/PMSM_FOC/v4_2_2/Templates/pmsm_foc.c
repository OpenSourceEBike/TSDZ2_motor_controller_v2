/**
 * @file pmsm_foc.c
 * @date 2015-11-19
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 * @cond
 ***********************************************************************************************************************
 * PMSM_FOC v4.2.0 - Supports sensorless field oriented control (FOC) for permanent magnet synchronous motor(PMSM).
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-15:
 *     - Initial version
 *
 * 2015-11-19:
 *     - FOC library code integrated
 *
 * @endcond
 *
 */
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "pmsm_foc.h"

/**
 * @cond INTERNAL_DOCS
 */
/**
 * @ingroup PMSM_FOC_privatefunc
 * @{
 */
/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/
#if (PMSM_FOC_IS_ADC_AVAILABLE == 1U)
/**
 * @brief This function do the ADC configurations
 * @param[in] HandlePtr Handler of the PMSM_FOC APP
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
static PMSM_FOC_STATUS_t PMSM_FOC_ADCConfig(PMSM_FOC_ADCConfig_t*const HandlePtr);

/**
 * @brief This function do ADC group and result resistor initialization
 * @param[in] HandlePtr Handler of the PMSM_FOC APP
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
static void PMSM_FOC_ADCGroupConfig(PMSM_FOC_ADCConfig_t*const HandlePtr);

#endif


/**
 * @brief This function do the ISR configuration.
 * @param[in] HandlePtr Handler of the ISR module of PMSM_FOC APP
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
static void PMSM_FOC_ISRInit(PMSM_FOC_ISRHandle_t* const HandlePtr);

/**
 * @brief This function do ADC queue entry configuration.
 * @param[in] HandlePtr Handler of type PMSM_FOC_ADCConfig_t
 * @param[in] queue_entry
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
static void PMSM_FOC_lADCQueueEntry(PMSM_FOC_ADCConfig_t * const HandlePtr, uint8_t queue_entry);

/**
 * @brief This function do all consumed APP's initialization.
 * @param[in] HandlePtr Handler of type PMSM_FOC APP
 * @return PMSM_FOC_STATUS_t
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
static PMSM_FOC_STATUS_t PMSM_FOC_DependentAppInit(PMSM_FOC_t* const HandlePtr);

static void PMSM_FOC_AngleRamp (PMSM_FOC_t *const HandlePtr);

static PMSM_FOC_STATUS_t PMSM_FOC_API_Paramter_Limit_Check(uint16_t *Kx, uint32_t value);

/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
/* To get the APP version information */
DAVE_APP_VERSION_t PMSM_FOC_GetAppVersion(void)
{
  DAVE_APP_VERSION_t version;

  version.major = PMSM_FOC_MAJOR_VERSION;
  version.minor = PMSM_FOC_MINOR_VERSION;
  version.patch = PMSM_FOC_PATCH_VERSION;

  return version;
}


/* Initialize PMSM_FOC APP parameters and low level APPs*/
PMSM_FOC_STATUS_t PMSM_FOC_Init(PMSM_FOC_t* const HandlePtr)
{
  uint32_t status = (uint32_t) PMSM_FOC_STATUS_SUCCESS;

  /* delay for driver IC stability */
  volatile uint32_t delay_counter = 0;
  for(delay_counter = 0U; delay_counter < PMSM_FOC_DELAY_COUNT; delay_counter++);

  if ((uint8_t) PMSM_FOC_STATE_UNINITIALISED == HandlePtr->state)
  {

    PMSM_FOC_ISRInit(HandlePtr->fcl_config_ptr);
    PMSM_FOC_ISRInit(HandlePtr->trap_config_ptr);

    status |= (uint32_t) PMSM_FOC_DependentAppInit(HandlePtr);
    if(HandlePtr->foc_config_ptr->fcl_divider > 1U)
    {
      XMC_CCU8_SLICE_EnableEvent(HandlePtr->pwm_svm_ptr->phase_ptr[1]->slice_ptr,XMC_CCU8_SLICE_IRQ_ID_ONE_MATCH);
    }

    /* ADC Configuration for measurement */
    if (PMSM_FOC_STATUS_FAILURE == PMSM_FOC_ADCConfig(HandlePtr->adc_config_ptr))
    {
      status |= (uint32_t)PMSM_FOC_STATUS_FAILURE;
    }

    if (status != (uint32_t) PMSM_FOC_STATUS_FAILURE)
    {
      HandlePtr->state = (uint8_t) PMSM_FOC_STATE_INITIALISED;
    }
    else
    {
      HandlePtr->operational_error |= ((uint32_t) 1 << (uint32_t) PMSM_FOC_EID_INIT_FAILED);
      HandlePtr->msm_state = PMSM_FOC_MSM_ERROR;

    }
  }
  return ((PMSM_FOC_STATUS_t) status);
}

static PMSM_FOC_STATUS_t PMSM_FOC_DependentAppInit(PMSM_FOC_t* const HandlePtr)
{
  uint32_t status = (uint32_t) PMSM_FOC_STATUS_SUCCESS;

  /* PWM SVM Init */
  if ((uint8_t) PMSM_FOC_STATUS_FAILURE == (uint8_t) PWM_SVM_Init(HandlePtr->pwm_svm_ptr))
  {
    status |= (uint32_t) PMSM_FOC_STATUS_FAILURE;

  }
  return (PMSM_FOC_STATUS_t) (status);
}

/*********************Start: ADC queue initialization *****************************/
static void PMSM_FOC_lADCQueueEntry(PMSM_FOC_ADCConfig_t *const HandlePtr,uint8_t queue_entry)
{
  uint8_t queue_entry_num;
  /*Insertion of queue entry for conversion*/
  for(queue_entry_num = 0U; queue_entry_num < PMSM_FOC_MAX_ADCCHANNELS; queue_entry_num++)
  {
    if(NULL != HandlePtr->queue_entry_hdlarray[queue_entry_num][queue_entry])
    {
      ADC_QUEUE_InsertQueueEntry(HandlePtr->qapp_handlearray[queue_entry],
          HandlePtr->queue_entry_hdlarray[queue_entry_num][queue_entry]);
    }
  }
}

static PMSM_FOC_STATUS_t PMSM_FOC_ADCConfig(PMSM_FOC_ADCConfig_t*const HandlePtr)
{
  uint8_t queue_entry;
#if(PMSM_FOC_ADC_CALIBRATION == 1U)
#if (UC_SERIES == XMC13)
  volatile uint32_t count;
#endif
#endif

  uint32_t adc_status = (uint32_t)PMSM_FOC_STATUS_SUCCESS;
  /*Queue APP initialization*/
  for(queue_entry = 0U; queue_entry < PMSM_FOC_MAX_ADCQUEUE; queue_entry++)
  {
    if((uint8_t)PMSM_FOC_QUEUE_ACTIVE == HandlePtr->queue_active[queue_entry])
    {
      adc_status |= (uint32_t)ADC_QUEUE_Init(HandlePtr->qapp_handlearray[queue_entry]);
    }
  }
  /* ADC group and result resistor configuration */
  PMSM_FOC_ADCGroupConfig(HandlePtr);

  for(queue_entry = 0U; queue_entry < PMSM_FOC_MAX_ADCQUEUE; queue_entry++)
  {
    if((uint8_t)PMSM_FOC_QUEUE_ACTIVE == HandlePtr->queue_active[queue_entry])
    {
      /*Insertion of queue entry for conversion*/
      PMSM_FOC_lADCQueueEntry(HandlePtr,queue_entry);

#if(PMSM_FOC_ADC_CALIBRATION == 1U)
#if (UC_SERIES == XMC13)
      /*ADC work around code */
      VADC -> GLOBCFG = 0x80038000;
      for(count=0U; count<1000U; count++)
      {
        ;
      }
      while((SHS0->SHSCFG & SHS_SHSCFG_STATE_Msk) == ((uint32_t)0x0011 <<SHS_SHSCFG_STATE_Pos))
      {
        ;
      }
      /*ADC_AI0040*/
      (*(unsigned int*) 0x480340E0 ) = 0x80008000;
      /*ADC_AI0041*/
      (*(unsigned int*) 0x480340E4 ) = 0x80008000;
#endif
#endif
      ADC_QUEUE_AllEntriesInserted(HandlePtr->qapp_handlearray[queue_entry]);
    }
  }
  return (adc_status);
}

/* ADC group and result resistor initialization*/
static void PMSM_FOC_ADCGroupConfig(PMSM_FOC_ADCConfig_t*const HandlePtr)
{
  uint8_t queue_entry;

  for(queue_entry = 0U; queue_entry < PMSM_FOC_MAX_ADCCHANNELS; queue_entry++)
  {
    /*channel and IO initialization*/
    if(NULL != HandlePtr->vadc_chhandle_array[queue_entry])
    {
      HandlePtr->vadc_chhandle_array[queue_entry]->input_class =
        (uint8_t)HandlePtr->qapp_handlearray[queue_entry]->iclass_num;
      XMC_VADC_GROUP_ChannelInit(HandlePtr->vadc_group_pointerarray[queue_entry],
          (uint32_t)HandlePtr->channel_num_array[queue_entry],
          HandlePtr->vadc_chhandle_array[queue_entry]);
    }

    /*Result initialization*/
    if(NULL != HandlePtr->vadc_reshandle_array[queue_entry])
    {
        XMC_VADC_GROUP_ResultInit(HandlePtr->vadc_group_pointerarray[queue_entry],
            (uint32_t)HandlePtr->result_num_array[queue_entry],
            HandlePtr->vadc_reshandle_array[queue_entry]);
    }
  }
}
/*********************End: ADC queue initialization *****************************/
/*
 * This function configure the the NVIC Node.
 */
static void PMSM_FOC_ISRInit(PMSM_FOC_ISRHandle_t* const HandlePtr)
{
  /*set the priority and sub priority*/
#if (UC_FAMILY == XMC1)
  NVIC_SetPriority((IRQn_Type) HandlePtr->node_id, (uint32_t) HandlePtr->priority);
#else
  NVIC_SetPriority((IRQn_Type)HandlePtr->node_id,
      NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
          (uint32_t)HandlePtr->priority,(uint32_t)HandlePtr->sub_priority));
#endif
  /*Enable the IRQ*/
  NVIC_EnableIRQ((IRQn_Type) HandlePtr->node_id);
}

/* Motor parameters initialization */
void PMSM_FOC_MotorParamInit(PMSM_FOC_t* const HandlePtr)
{

  HandlePtr->pwm_svm_ptr->phasev_crs = HandlePtr->pwm_svm_ptr->confighandle_ptr->config_phasev_crs;
  HandlePtr->pwm_svm_ptr->phasew_crs = HandlePtr->pwm_svm_ptr->confighandle_ptr->config_phasew_crs;
  HandlePtr->ph_v_group = (uint8_t)PMSM_FOC_PHASE_V_CURRENT;
  HandlePtr->ph_w_group = (uint8_t)PMSM_FOC_PHASE_W_CURRENT;

  /* Anti-clockwise direction */
  if(HandlePtr->motor_direction == PMSM_FOC_NEGATIVE_DIR)
  {
    HandlePtr->pwm_svm_ptr->phasev_crs = HandlePtr->pwm_svm_ptr->confighandle_ptr->config_phasew_crs;
    HandlePtr->pwm_svm_ptr->phasew_crs = HandlePtr->pwm_svm_ptr->confighandle_ptr->config_phasev_crs;
    HandlePtr->ph_v_group = (uint8_t)PMSM_FOC_PHASE_W_CURRENT;
    HandlePtr->ph_w_group = (uint8_t)PMSM_FOC_PHASE_V_CURRENT;
  }

  /* End: Anti-clockwise direction */

  HandlePtr->angle = (uint32_t) 0;
  HandlePtr->amplitude = (uint32_t) 0;
  HandlePtr->motor_speed = 0;
  HandlePtr->bootstrap_index = 0U;
  HandlePtr->counter = 0U;
  HandlePtr->alignment_counter = 0U;
  HandlePtr->ramp_counter = 0U;
  HandlePtr->volt_protect_counter = 0U;
  HandlePtr->mode_flag = (uint8_t)PMSM_FOC_FLAG_TRANSITION;
  HandlePtr->speed_set = HandlePtr->start_speed;
  HandlePtr->ramp_up_rate = HandlePtr->foc_config_ptr->config_ramp_up_rate << HandlePtr->ramp_s_ratio;
  HandlePtr->ramp_down_rate = HandlePtr->foc_config_ptr->config_ramp_down_rate << (HandlePtr->ramp_s_ratio - (uint32_t)1);
  HandlePtr->vf_ramp_up_rate = (HandlePtr->foc_config_ptr->config_vf_rampup_rate);
  HandlePtr->FOCInput->I_U = 0;
  HandlePtr->FOCInput->I_V = 0;
  HandlePtr->FOCInput->I_W = 0;

  HandlePtr->PI_Flux->Ik = 0;
  HandlePtr->PI_PLL->Ik = 0;
  HandlePtr->PI_Speed->Ik = 0;
  HandlePtr->PI_Torque->Ik = 0;

}

/*************************************************************************************************************************/

/* Starts the motor with given configurations */
void PMSM_FOC_MotorStart(PMSM_FOC_t* const HandlePtr)
{
  /* Motor State machine should be in STOP state to start the motor.
   * In case of any error, motor start function won't be started
   * until clear all the errors.
   */
  if (PMSM_FOC_MSM_STOP == HandlePtr->msm_state)
  {
    HandlePtr->msm_state = PMSM_FOC_MSM_INIT_INVERTER;
    /* Call Motor State Machine */
    PMSM_FOC_MSM(HandlePtr);
  }
}

/* Stops the motor and low level APPs */
void PMSM_FOC_MotorStop(PMSM_FOC_t* const HandlePtr)
{
  /*stop pwm svm*/
  PWM_SVM_Stop(HandlePtr->pwm_svm_ptr);
  HandlePtr->motor_speed = 0;

  if (((HandlePtr->operational_error) != 0U))
  {
    HandlePtr->msm_state = PMSM_FOC_MSM_ERROR;
    /*call the motor state machine, to report the error*/
    PMSM_FOC_MSM(HandlePtr);
  }
  else
  {
    /* Change motor control state machine to stop */
    HandlePtr->msm_state = PMSM_FOC_MSM_STOP;
  }
}

/*Amplifier bias voltage calibration*/
void PMSM_FOC_AmpBiasVoltCalibration(PMSM_FOC_t* const HandlePtr)
{
  volatile uint32_t amp_offset = 0U;
  volatile uint32_t count,delay_count;
  uint32_t temp_amplifier_offset;
  uint8_t adc_config_entry = (uint8_t)PMSM_FOC_PHASE_U_CURRENT;

  /* Current Amplifier bias voltage calibration and Current measurement are enable
   * Calculate the current amplifier bias voltage  */
  if(1U == HandlePtr->foc_config_ptr->enable_biasvoltage)
  {
    if(HandlePtr->foc_config_ptr->phase_current_measurement == (uint8_t)PMSM_FOC_DCLINK)
    {
      adc_config_entry = (uint8_t)PMSM_FOC_DCLINK_CURRENT;
    }
    /* ADC bias voltage measurement */
    for(count = 0U; count < PMSM_FOC_ADCCAL_COUNT; count++)
    {
      XMC_VADC_GROUP_QueueTriggerConversion(HandlePtr->adc_config_ptr->vadc_group_pointerarray[adc_config_entry]);
      for(delay_count = 0U; delay_count < 0xFF; delay_count++);
      temp_amplifier_offset = XMC_VADC_GROUP_GetResult(HandlePtr->adc_config_ptr->vadc_group_pointerarray[adc_config_entry],
          (uint32_t)HandlePtr->adc_config_ptr->result_num_array[adc_config_entry]);
      amp_offset = amp_offset + temp_amplifier_offset;
    }
    HandlePtr->amplifier_offset = (uint16_t)(amp_offset/PMSM_FOC_ADCCAL_COUNT);
  }
  else
  {
    HandlePtr->amplifier_offset = (uint16_t)(HandlePtr->foc_config_ptr->current_amplifier_offset >> 2U);
  }
}

void PMSM_FOC_StartPWMTimer(PMSM_FOC_t* const HandlePtr)
{
  volatile uint8_t phase_count;
  PWM_SVM_t* const module_ptr = HandlePtr->pwm_svm_ptr;

  for (phase_count = (uint8_t) 0; phase_count < (uint8_t) 4; phase_count++)
  {
    /* configure the Start trigger function*/
    XMC_CCU8_SLICE_StartConfig(module_ptr->phase_ptr[phase_count]->slice_ptr,
        (XMC_CCU8_SLICE_EVENT_t) XMC_CCU8_SLICE_EVENT_0,
        (XMC_CCU8_SLICE_START_MODE_t) XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
  }
  /* synchronous start of CCU8 slices */
  XMC_SCU_SetCcuTriggerHigh(module_ptr->confighandle_ptr->sync_start_mask);

  for (phase_count = (uint8_t) 0; phase_count < (uint8_t) 4; phase_count++)
  {
    /* disable external start*/
    XMC_CCU8_SLICE_StartConfig(module_ptr->phase_ptr[phase_count]->slice_ptr,
        (XMC_CCU8_SLICE_EVENT_t) XMC_CCU8_SLICE_EVENT_NONE,
        (XMC_CCU8_SLICE_START_MODE_t) XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
  }
}

void PMSM_FOC_StopPWMTimer(PMSM_FOC_t* const HandlePtr)
{
  /* synchronous stop of CCU8 slices */
  XMC_SCU_SetCcuTriggerLow(HandlePtr->pwm_svm_ptr->confighandle_ptr->sync_start_mask);
}

void PMSM_FOC_BootstrapConfiguration(PMSM_FOC_t* const HandlePtr)
{
  volatile uint8_t phase_count;
  PWM_SVM_t * const module_ptr = HandlePtr->pwm_svm_ptr;

  /*Bootstrapping*/
  for (phase_count = (uint8_t) 0; phase_count < (uint8_t) 3; phase_count++)
  {
    /* Update channel 1 compare value (CR1) of slice */
    XMC_CCU8_SLICE_SetTimerCompareMatch(module_ptr->phase_ptr[phase_count]->slice_ptr,
        (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) 0xFFFFU);
    /*Disable PWM Asymmetrical, if this is enabled*/
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[phase_count]->slice_ptr, 0x1E0014U);
  }

  /*Enable the shadow transfer for all three consumed slice*/
  XMC_CCU8_EnableShadowTransfer(module_ptr->global_ptr, module_ptr->confighandle_ptr->shadow_transfer_mask);
}

void PMSM_FOC_ClearErrorState(PMSM_FOC_t* const HandlePtr)
{
  HandlePtr->operational_error = 0U;
  HandlePtr->msm_state = PMSM_FOC_MSM_STOP;
}

PMSM_FOC_BOOTSTRAP_STATUS_t PMSM_FOC_Bootstrap(PMSM_FOC_t* const HandlePtr)
{
  PMSM_FOC_BOOTSTRAP_STATUS_t status = PMSM_FOC_BOOTSTRAP_ACTIVE;

  /*Enable Bootstrap for Phase U*/
  if (HandlePtr->bootstrap_index < HandlePtr->bootstrap_count)
  {
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[0U]->slice_ptr, 0x1E0000U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[1U]->slice_ptr, 0x1E0014U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[2U]->slice_ptr, 0x1E0014U);
  }
  /*Enable Bootstrap for Phase V*/
  else if (HandlePtr->bootstrap_index < (HandlePtr->bootstrap_count * 2U))
  {
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[0U]->slice_ptr, 0x1E0014U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[1U]->slice_ptr, 0x1E0000U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[2U]->slice_ptr, 0x1E0014U);
  }
  /*Enable Bootstrap for Phase W*/
  else if (HandlePtr->bootstrap_index < (HandlePtr->bootstrap_count * 3U))
  {
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[0U]->slice_ptr, 0x1E0014U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[1U]->slice_ptr, 0x1E0014U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[2U]->slice_ptr, 0x1E0000U);
  }
  else
  {
    /*Configure default value*/
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[0U]->slice_ptr, 0x170000U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[1U]->slice_ptr, 0x170000U);
    XMC_CCU8_SLICE_SetOutPath(HandlePtr->pwm_svm_ptr->phase_ptr[2U]->slice_ptr, 0x170000U);
    status = PMSM_FOC_BOOTSTRAP_COMPLETED;
  }
  HandlePtr->bootstrap_index++;
  return (status);
}

/* --------------------------------------------------------------------------------------------------------------------*/
void PMSM_FOC_Vf_RampUp (PMSM_FOC_t*const HandlePtr)
{
  uint32_t amplitude = 0U;
  uint32_t buffer;

  /* To get I_Alpha and I_Beta of last PWM cycle, scale down I_Mag (i.e.: |I|) by 2/3.*/
#if (PMSM_FOC_IS_3PHASE == 1U)         /* For 3-shunt phase current sensing. */
  /* I_Alpha = (2 * I_U - (I_V + I_W))/3.*/
  HandlePtr->FOCOutput->I_Alpha_1Q31 =
      ((HandlePtr->FOCInput->I_U << 1U) - (HandlePtr->FOCInput->I_V + HandlePtr->FOCInput->I_W)) *
          (int32_t)((uint32_t)PMSM_FOC_DIV_3 << ((uint32_t)PMSM_FOC_CORDIC_SHIFT - (uint32_t)PMSM_FOC_SCALE_DIV_3));
  /* I_Beta = (I_V - I_W)/√3 in 1Q31.*/
  HandlePtr->FOCOutput->I_Beta_1Q31 = (HandlePtr->FOCInput->I_V - HandlePtr->FOCInput->I_W) *
      (int32_t)((uint32_t)PMSM_FOC_DIV_SQRT3 << ((uint32_t)PMSM_FOC_CORDIC_SHIFT - (uint32_t)PMSM_FOC_SCALE_SQRT3));
#else
  /* I_Alpha = I_U in 1Q31 data format.*/
  HandlePtr->FOCOutput->I_Alpha_1Q31 = HandlePtr->FOCInput->I_U << PMSM_FOC_CORDIC_SHIFT;
  /* I_Beta = (I_U + 2 * I_V)/√3 in 1Q31.*/
  HandlePtr->FOCOutput->I_Beta_1Q31 = (HandlePtr->FOCInput->I_U + (HandlePtr->FOCInput->I_V << 1U)) *
      (PMSM_FOC_DIV_SQRT3 << ((uint32_t)PMSM_FOC_CORDIC_SHIFT-PMSM_FOC_SCALE_SQRT3));
#endif

  /* Rotor preposition/alignment counter ++.*/
  HandlePtr->alignment_counter++;
  if (HandlePtr->alignment_counter < HandlePtr->alignment_time)
  {
    /* Constant Vref voltage for rotor preposition/alignment.*/
    if (amplitude < HandlePtr->alignment_volt)
    {
      /* Vref increases gradually until being constant. */
      amplitude += HandlePtr->alignment_step;
    }
  }
  else
  {
    /* Update V/f voltage amplitude, Vref = Offset + Kω.*/
    amplitude = HandlePtr->vf_startup_ptr->vf_offset +
        (HandlePtr->vf_startup_ptr->vf_constant * ((uint32_t)HandlePtr->speed_set >> HandlePtr->FOCInput->Res_Inc));
    PMSM_FOC_AngleRamp (HandlePtr);            /* To update angle θ (16-bit) of SVM reference vector Vref.*/

    if (HandlePtr->mode_flag == (uint8_t)PMSM_FOC_FLAG_TRANSITION)
    {
     /* Motor is in transition mode,*/
     if (HandlePtr->speed_set < HandlePtr->vf_startup_ptr->vf_threshold_speed)
     {
       /* Motor speed not yet reached to transition speed.*/
       HandlePtr->ramp_counter ++;              /* Speed ramp counter ++.*/
       if (HandlePtr->ramp_counter > HandlePtr->vf_ramp_up_rate)
       {
         /* Ramp up slowly in V/f.*/
         if (HandlePtr->vf_ramp_up_rate > (HandlePtr->foc_config_ptr->config_vf_rampup_rate ))
         {
           HandlePtr->vf_ramp_up_rate --;          /* Increase acceleration step by step.*/
         }

         HandlePtr->speed_set ++;       /* Motor speed ++.*/
         HandlePtr->ramp_counter = 0U;     /* Clear ramp counter.*/
       }
     }
     else
     {
       /* Motor run at V/f constant speed for a while.*/
       HandlePtr->counter ++;
       if (HandlePtr->counter > HandlePtr->vf_startup_ptr->vf_time)
       {
         HandlePtr->mode_flag = (uint8_t)PMSM_FOC_FLAG_STABLE;   /* Change flag: motor in stable mode of V/f ramp-up.*/
         HandlePtr->counter = 0U;
       }
     }
    }

    /* Motor is in stable state in v/f */
    else
    {
      HandlePtr->msm_state = PMSM_FOC_MSM_TRANSITION;
      HandlePtr->FOCInput->BEMF1 = 0;
      HandlePtr->FOCInput->BEMF2 = 0U;

      /* MET loop unlocked */
      HandlePtr->FOCInput->Threshold = ((uint32_t)HandlePtr->speed_set * HandlePtr->FOCInput->Threshold_LOW) >>
          HandlePtr->FOCInput->Res_Inc;

      /* Smooth MET transition feature is not enabled */
      if (HandlePtr->foc_config_ptr->enable_transition == 0U)
      {
        HandlePtr->msm_state = PMSM_FOC_MSM_NORMAL_OPERATION;
        /* Init FOC rotor speed ωr = PI_PLL.Uk, needed for ωL|I|, ωLId, ωLIq, and FG frequency calculation.*/
        HandlePtr->PI_PLL->Uk = HandlePtr->speed_set;

        /* Init Vq's Ik = |Vref| of torque / Iq PI controller.*/

        buffer = amplitude << (uint16_t)HandlePtr->PI_Torque->Scale_KpKi;
        HandlePtr->PI_Torque->Ik = (int32_t)(buffer);
        /* Init Vd's Ik = 0 of flux / Id PI controller.*/
        HandlePtr->PI_Flux->Ik = 0;
        PMSM_FOC_Controller_Init_OnceOnly (HandlePtr);
      }

      /*To use V/f only, no MET or FOC.*/
      if (HandlePtr->foc_config_ptr->enable_vf_only == 1U)
      {
        HandlePtr->msm_state = PMSM_FOC_MSM_VF_OPEN_LOOP;
      }

      HandlePtr->counter = 0U;                                  /* Clear counters.*/
      HandlePtr->ramp_counter = 0U;
      HandlePtr->alignment_counter = 0U;
      HandlePtr->mode_flag = (uint8_t)PMSM_FOC_FLAG_TRANSITION;
      /* Slower ramp up and ramp down for S-curve profile.*/
      HandlePtr->ramp_up_rate = HandlePtr->foc_config_ptr->config_ramp_up_rate << HandlePtr->ramp_s_ratio;
    }

    /* 14-bit representation for SVM */
    HandlePtr->amplitude = amplitude>>1U;

    /* Record SVM reference vector magnitude (32-bit) of last PWM cycle.*/
    HandlePtr->vref32_store = HandlePtr->vref32;
    HandlePtr->vref32 = HandlePtr->amplitude << (PMSM_FOC_CORDIC_SHIFT + 1);
    HandlePtr->FOCInput->Vref_AngleQ31 = (int32_t)HandlePtr->vref_angle32;
    /* Init for smooth transition from V/f to FOC closed-loop.*/
    Init_Smooth_Transition_To_FOC (HandlePtr, HandlePtr->speed_set);
    HandlePtr->motor_speed = HandlePtr->speed_set;
  }
}/* End of Vf_RampUp ()*/


static void PMSM_FOC_AngleRamp (PMSM_FOC_t *const HandlePtr)
{
  int32_t angle;
  HandlePtr->vref_angle32_store = HandlePtr->vref_angle32;   /* Record Vref angle θ of last PWM cycle. */

  /* θ[k] = θ[k-1] +/- ω[k].*/
  HandlePtr->vref_angle32 += (HandlePtr->speed_set << (16U - HandlePtr->FOCInput->Res_Inc));

  /* SVM Vref angle θ (24-bit).*/
  angle = (HandlePtr->vref_angle32 >> (uint32_t)8);
  HandlePtr->angle = (uint32_t)(angle);
 }  /* End of PMSM_FOC_AngleRamp ()*/



void PMSM_FOC_Vf_Open_Loop (PMSM_FOC_t *const HandlePtr)
{
  uint32_t amplitude;
    /* To get I_Alpha and I_Beta of last PWM cycle, scale down I_Mag (i.e.: |I|) by 2/3.*/
  #if (PMSM_FOC_IS_3PHASE == 1U)         /* For 3-shunt phase current sensing. */
    /* I_Alpha = (2 * I_U - (I_V + I_W))/3.*/
  HandlePtr->FOCOutput->I_Alpha_1Q31 =
      ((HandlePtr->FOCInput->I_U << 1U) - (HandlePtr->FOCInput->I_V + HandlePtr->FOCInput->I_W)) *
          (int32_t)((uint32_t)PMSM_FOC_DIV_3 << ((uint32_t)PMSM_FOC_CORDIC_SHIFT - (uint32_t)PMSM_FOC_SCALE_DIV_3));
  /* I_Beta = (I_V - I_W)/√3 in 1Q31.*/
  HandlePtr->FOCOutput->I_Beta_1Q31 = (HandlePtr->FOCInput->I_V - HandlePtr->FOCInput->I_W) *
      (int32_t)((uint32_t)PMSM_FOC_DIV_SQRT3 << ((uint32_t)PMSM_FOC_CORDIC_SHIFT - (uint32_t)PMSM_FOC_SCALE_SQRT3));
  #else
    /* I_Alpha = I_U in 1Q31 data format.*/
    HandlePtr->FOCOutput->I_Alpha_1Q31 = HandlePtr->FOCInput->I_U << PMSM_FOC_CORDIC_SHIFT;
    /* I_Beta = (I_U + 2 * I_V)/√3 in 1Q31.*/
    HandlePtr->FOCOutput->I_Beta_1Q31 = (HandlePtr->FOCInput->I_U + (HandlePtr->FOCInput->I_V << 1)) *
             (PMSM_FOC_DIV_SQRT3 << (PMSM_FOC_CORDIC_SHIFT-PMSM_FOC_SCALE_SQRT3));
  #endif

       /* Motor in transition mode.*/
    if(HandlePtr->speed_set != (HandlePtr->user_speed_set))
    {
      if (HandlePtr->speed_set < (HandlePtr->user_speed_set))
      {
        /* Motor speed not reach target speed.*/
        HandlePtr->ramp_counter ++;              /* Speed ramp counter ++.*/
        if (HandlePtr->ramp_counter > HandlePtr->vf_ramp_up_rate)
        {
          /* Ramp up slowly in V/f.*/
          if (HandlePtr->vf_ramp_up_rate > (HandlePtr->foc_config_ptr->config_vf_rampup_rate ))
          {
            HandlePtr->vf_ramp_up_rate --;          /* Increase acceleration step by step.*/
          }

          HandlePtr->speed_set ++;               /* Motor speed ++.*/
          HandlePtr->ramp_counter = 0U;           /* Clear ramp counter.*/
        }
      }
      else
      {
        HandlePtr->ramp_counter ++;
        if (HandlePtr->ramp_counter > HandlePtr->vf_ramp_up_rate)
        {
          HandlePtr->speed_set --;
          HandlePtr->ramp_counter = 0U;
        }
      }
    }
    else
    {
      HandlePtr->vf_ramp_up_rate = (HandlePtr->foc_config_ptr->config_vf_rampup_rate << HandlePtr->ramp_s_ratio);
    }

    /* Update V/f voltage amplitude, Vref = Offset + Kω.*/
    amplitude = HandlePtr->vf_startup_ptr->vf_offset +
        (HandlePtr->vf_startup_ptr->vf_constant * ((uint32_t)HandlePtr->speed_set >> HandlePtr->FOCInput->Res_Inc));
    PMSM_FOC_AngleRamp (HandlePtr);            /* To update angle θ (16-bit) of SVM reference vector Vref.*/

    HandlePtr->motor_speed = HandlePtr->speed_set;
    if (amplitude > (uint32_t)PMSM_FOC_POWER215)
    {
      /* Limit |Vref|maximum value.*/
      amplitude = (uint32_t)PMSM_FOC_POWER215;
    }
    /* 14-bit format for SVM amplitude */
    HandlePtr->amplitude = (amplitude>>1U);
} /* End of Vf_Open_Loop ()*/




void PMSM_FOC_METTransition (PMSM_FOC_t* const HandlePtr)
{
  if (HandlePtr->mode_flag == (uint8_t)PMSM_FOC_FLAG_TRANSITION)
  {
    /* Motor in transition mode. Motor goes to higher speed first, important for startup. */
    if (HandlePtr->speed_set < HandlePtr->vf_startup_ptr->vf_threshold_speed)
    {
      HandlePtr->ramp_counter ++;
      if (HandlePtr->ramp_counter > HandlePtr->ramp_up_rate)
      {
        /* Ramp up slowly (if needed) at start of FOC. */
        HandlePtr->speed_set ++;
        HandlePtr->ramp_counter = 0U;
      }
    }
    else
    {
      HandlePtr->ramp_counter ++;
      if (HandlePtr->ramp_counter > HandlePtr->met_stable_time)
      {
        /* Change flag: in FOC stable mode. */
        HandlePtr->mode_flag = (uint8_t)PMSM_FOC_FLAG_STABLE;
        HandlePtr->counter = 0U;
      }
    }
  }
  else
  {
    /* Transition from MET to FOC, using 3-step motor start-up V/f->MET->FOC */
    PMSM_FOC_Transition_to_FOC(HandlePtr);
  }
}


void PMSM_FOC_Transition_to_FOC (PMSM_FOC_t* const HandlePtr)
{
  HandlePtr->msm_state = PMSM_FOC_MSM_NORMAL_OPERATION;

  Init_FOC_RotorAngle (HandlePtr);
  /* To init PI controllers' Ik for first FOC PWM cycle. */
  Init_FOC_PI_Iks (HandlePtr);

  HandlePtr->PI_PLL->Uk = HandlePtr->speed_set;
  HandlePtr->FOCInput->Ref_Speed = HandlePtr->speed_set;

  /* Init parameters of FOC LIB. Init once only. */
  PMSM_FOC_Controller_Init_OnceOnly (HandlePtr);
  HandlePtr->mode_flag = (uint8_t)PMSM_FOC_FLAG_TRANSITION;
  HandlePtr->counter = 0U;
  HandlePtr->ramp_counter = 0U;
}/* End of Transition_to_FOC () */

/* Rotor initial preposition/alignment */

void PMSM_FOC_Rotor_Pre_Positioning (PMSM_FOC_t* const HandlePtr)
{
  uint32_t buffer;
  /* To get I_Alpha and I_Beta of last PWM cycle, scale down I_Mag (i.e.: |I|) by 2/3. */
#if (PMSM_FOC_IS_3PHASE == 1U)
  /* For 3-shunt phase current sensing. */
    /* I_Alpha = (2 * I_U - (I_V + I_W))/3. */
  HandlePtr->FOCOutput->I_Alpha_1Q31 =
      ((HandlePtr->FOCInput->I_U << 1U) - (HandlePtr->FOCInput->I_V + HandlePtr->FOCInput->I_W)) *
          (int32_t)((uint32_t)PMSM_FOC_DIV_3 << ((uint32_t)PMSM_FOC_CORDIC_SHIFT - (uint32_t)PMSM_FOC_SCALE_DIV_3));
  /* I_Beta = (I_V - I_W)/√3 in 1Q31.*/
  HandlePtr->FOCOutput->I_Beta_1Q31 = (HandlePtr->FOCInput->I_V - HandlePtr->FOCInput->I_W) *
      (int32_t)((uint32_t)PMSM_FOC_DIV_SQRT3 << ((uint32_t)PMSM_FOC_CORDIC_SHIFT - (uint32_t)PMSM_FOC_SCALE_SQRT3));
#else
  // I_Alpha = I_U in 1Q31 data format.
  HandlePtr->FOCOutput->I_Alpha_1Q31 = HandlePtr->FOCInput->I_U << PMSM_FOC_CORDIC_SHIFT;
  /* I_Beta = (I_U + 2 * I_V)/v3 in 1Q31. */
  HandlePtr->FOCOutput->I_Beta_1Q31 = (HandlePtr->FOCInput->I_U + (HandlePtr->FOCInput->I_V << 1)) *
      (PMSM_FOC_DIV_SQRT3 << (PMSM_FOC_CORDIC_SHIFT-PMSM_FOC_SCALE_SQRT3));
#endif

    HandlePtr->msm_state = PMSM_FOC_MSM_NORMAL_OPERATION;
    /* Motor in transition mode. */
    HandlePtr->mode_flag = (uint8_t)PMSM_FOC_FLAG_TRANSITION;
    HandlePtr->alignment_counter = 0U;            /* Clear counter. */
    /* Init FOC rotor speed ?r = PI_PLL->Uk, needed for ?L|I|, ?LId, ?LIq, and FG frequency calculation.*/
    HandlePtr->PI_PLL->Uk = HandlePtr->motor_speed;

    /* Init Vq's Ik = |Vref| of torque / Iq PI controller. */
    buffer = HandlePtr->amplitude << (uint16_t)HandlePtr->PI_Torque->Scale_KpKi;
    HandlePtr->PI_Torque->Ik = (int32_t)(buffer);
    HandlePtr->PI_Flux->Ik = 0;                          /* Init Vd's Ik = 0 of flux / Id PI controller. */

    /* Direct FOC startup. Motor startup to FOC closed-loop directly, no V/f or MET. */
    if(HandlePtr->foc_config_ptr->enable_direct_foc_startup == 1U)
    {
      /* Slower ramp up for S-curve profile of FOC. */
      HandlePtr->ramp_up_rate = HandlePtr->foc_config_ptr->config_ramp_up_rate << 2U;
    }

  /* Record SVM reference vector magnitude (32-bit) of last PWM cycle. */
  HandlePtr->vref32_store = HandlePtr->vref32;
  HandlePtr->vref32 = HandlePtr->amplitude << PMSM_FOC_CORDIC_SHIFT;

  /* Init for smooth transition from V/f to FOC closed-loop. */
  Init_Smooth_Transition_To_FOC (HandlePtr, HandlePtr->motor_speed);

  if (HandlePtr->msm_state == PMSM_FOC_MSM_NORMAL_OPERATION)
  {
    /* Init parameters of FOC LIB. Init once only. */
    PMSM_FOC_Controller_Init_OnceOnly (HandlePtr);
  }

}  /* End of PMSM_FOC_Rotor_Pre_Positioning () */

__INLINE void PMSM_FOC_Controller_Init_OnceOnly (PMSM_FOC_t* const HandlePtr)
{

  HandlePtr->FOCInput->RotorSpeed_In = 0;

  HandlePtr->FOCInput->Vref_AngleQ31 = HandlePtr->vref_angle32;  /* First time voltage angle and magnitude.*/
  HandlePtr->FOCInput->Vref32 = (HandlePtr->vref32);

  HandlePtr->FOCInput->RotorSpeed_In = HandlePtr->motor_speed;
  HandlePtr->FOCInput->Ref_Speed = HandlePtr->motor_speed;      /* Motor reference speed. */

  HandlePtr->PI_PLL->Ik = HandlePtr->FOCInput->RotorSpeed_In << HandlePtr->PI_PLL->Scale_KpKi;

  HandlePtr->FOCInput->Previous_SVM_SectorNo = 0U;


}  /* End of PMSM_FOC_Controller_Init_OnceOnly () */


/* APIs to provide user setting FOC run time parameters  */

/* To set Motor Speed */

PMSM_FOC_STATUS_t PMSM_FOC_SetEndSpeed(PMSM_FOC_t*const HandlePtr,uint32_t speed)
{
  PMSM_FOC_STATUS_t status = PMSM_FOC_STATUS_INVALID_PARAM;

  speed = (speed * (HandlePtr->foc_config_ptr->speed_scale)) >> PMSM_FOC_Q15;

  if ((speed >= PMSM_FOC_API_PARAM_MIN_VALUE ) && (speed <= PMSM_FOC_API_PARAM_MAX_VALUE))
  {
    HandlePtr->user_speed_set = (int32_t)speed;
    status = PMSM_FOC_STATUS_SUCCESS;
  }
  return status;
}

/* To set Motor Speed threshold for transitioning from V/F to closed loop FOC */

PMSM_FOC_STATUS_t PMSM_FOC_SetVFEndSpeed(PMSM_FOC_t*const HandlePtr, uint32_t speed)
{
  PMSM_FOC_STATUS_t status = PMSM_FOC_STATUS_INVALID_PARAM;
  speed = (speed * (HandlePtr->foc_config_ptr->speed_scale)) >> PMSM_FOC_Q15;

  if ((speed >= PMSM_FOC_API_PARAM_MIN_VALUE ) && (speed <= PMSM_FOC_API_PARAM_MAX_VALUE))
  {
    HandlePtr->vf_startup_ptr->vf_threshold_speed = (int32_t)speed;
    status = PMSM_FOC_STATUS_SUCCESS;
  }
  return status;
}

/* API-To Get Motor Speed Feedback */

int32_t PMSM_FOC_GetMotorSpeed(PMSM_FOC_t* const HandlePtr)
{
  return (int32_t)
      (((int64_t) (HandlePtr->motor_speed) * ((int32_t)HandlePtr->foc_config_ptr->inv_speed_scale)) >> PMSM_FOC_Q15);
}

/* API-To Get Motor Speed Feedback */

int32_t PMSM_FOC_GetEndSpeed(PMSM_FOC_t* const HandlePtr)
{
  return (int32_t)
      (((int64_t) (HandlePtr->user_speed_set) * ((int32_t)HandlePtr->foc_config_ptr->inv_speed_scale)) >> PMSM_FOC_Q15);
}

/* API-To Set Motor Motor Direction */

PMSM_FOC_STATUS_t PMSM_FOC_SetMotorDirection(PMSM_FOC_t* const HandlePtr, PMSM_FOC_MD_t direction)
{

  PMSM_FOC_STATUS_t status = PMSM_FOC_STATUS_PERMISSION_DENIED;

  if  (HandlePtr->msm_state == PMSM_FOC_MSM_STOP)
  {
    if ( (direction==PMSM_FOC_POSITIVE_DIR) || (direction== PMSM_FOC_NEGATIVE_DIR))
    {
      /*set motor direction in PMSM_FOC APP*/
      HandlePtr->motor_direction = (int8_t) direction;
      status = PMSM_FOC_STATUS_SUCCESS;
    }
    else
    {
      status = PMSM_FOC_STATUS_INVALID_PARAM;
    }
  }
  return status;
}

/* This API return the motor direction */

PMSM_FOC_MD_t PMSM_FOC_GetMotorDirection(PMSM_FOC_t* const HandlePtr)
{
  return (PMSM_FOC_MD_t) (HandlePtr->motor_direction);
}

/* This API set the q-axis current reference for torque control in Q15 format */

PMSM_FOC_STATUS_t PMSM_FOC_SetIqRef(PMSM_FOC_t*const HandlePtr, int32_t current)
{
  PMSM_FOC_STATUS_t status = PMSM_FOC_STATUS_PERMISSION_DENIED;
  current = ((current * (int32_t)HandlePtr->foc_config_ptr->current_scale) >> PMSM_FOC_Q15);
  if  (HandlePtr->foc_config_ptr->enable_speed_control == 0U)
  {
    if ((current >= PMSM_FOC_CURRENT_MIN_VALUE ) && (current <= PMSM_FOC_CURRENT_MAX_VALUE))
    {
      HandlePtr->FOCInput->Ref_Iq = (int32_t) current;
      status = PMSM_FOC_STATUS_SUCCESS;
    }
    else
    {
      status = PMSM_FOC_STATUS_INVALID_PARAM;
    }
  }
  return status;
}

/* This API return the Iq_ref value in Q15 format */

int32_t PMSM_FOC_GetIqRef(PMSM_FOC_t*const HandlePtr)
{
   return  ((HandlePtr->FOCInput->Ref_Iq * (int32_t)HandlePtr->foc_config_ptr->inv_current_scale) >> PMSM_FOC_Q15);
}


/* This API set the d-axis current reference for flux-control in Q15 format */

PMSM_FOC_STATUS_t PMSM_FOC_SetIdRef(PMSM_FOC_t*const HandlePtr, int32_t current)

{
  PMSM_FOC_STATUS_t status = PMSM_FOC_STATUS_INVALID_PARAM;
  current = ((current * (int32_t)HandlePtr->foc_config_ptr->current_scale) >> PMSM_FOC_Q15);
  if ((current >= PMSM_FOC_CURRENT_MIN_VALUE ) && (current <= PMSM_FOC_CURRENT_MAX_VALUE))
  {
    HandlePtr->FOCInput->Ref_Id= (int32_t) current;
    status =PMSM_FOC_STATUS_SUCCESS;
  }
  else
  {
    status = PMSM_FOC_STATUS_INVALID_PARAM;
  }
  return status;
}

/* To set Motor Resistance */

PMSM_FOC_STATUS_t PMSM_FOC_SetMotorResistance(PMSM_FOC_t*const HandlePtr, uint32_t resistance)
{
  uint32_t resistance_target;
  PMSM_FOC_STATUS_t status = PMSM_FOC_STATUS_INVALID_PARAM;
  resistance_target = ((resistance >> 1U) * (HandlePtr->foc_config_ptr->resistance_scale)) >> PMSM_FOC_Q15;
  if ((resistance_target >= PMSM_FOC_API_PARAM_MIN_VALUE ) && (resistance_target <= PMSM_FOC_API_PARAM_MAX_VALUE))
  {
    HandlePtr->FOCInput->Phase_R = (uint16_t)resistance_target;
    status = PMSM_FOC_STATUS_SUCCESS;
  }
  return status;
}

/* To set Motor d and q axis inductance  */

PMSM_FOC_STATUS_t PMSM_FOC_SetMotorInductance(PMSM_FOC_t*const HandlePtr, uint32_t inductance_d, uint32_t inductance_q)
{
  PMSM_FOC_STATUS_t status = PMSM_FOC_STATUS_INVALID_PARAM;
  uint32_t inductance;
  uint32_t ph_inductance;

  inductance = ((inductance_d + inductance_q) >> 2U);

  /* Find the target value of the inductance */
  ph_inductance = (uint16_t)(inductance * ((HandlePtr->foc_config_ptr->inductance_scale << HandlePtr->FOCInput->Phase_L_Scale)
      >> (uint32_t)PMSM_FOC_Q15)) >> (uint32_t)PMSM_FOC_Q15;

  if((ph_inductance <= PMSM_FOC_API_PARAM_MAX_VALUE) && (ph_inductance >= PMSM_FOC_API_PARAM_MIN_VALUE))
  {
    HandlePtr->FOCInput->Phase_L = ph_inductance;
    status = PMSM_FOC_STATUS_SUCCESS;
  }

  return status;
}

/* To get present status of motor operation  */

PMSM_FOC_MSM_t PMSM_FOC_GetStatus(PMSM_FOC_t*const HandlePtr)

{
   return (HandlePtr->msm_state);
}

/* To set FOC MET Transition  */

PMSM_FOC_STATUS_t PMSM_FOC_SetTransitionLPFFactor(PMSM_FOC_t*const HandlePtr, uint16_t value)

{
  PMSM_FOC_STATUS_t status = PMSM_FOC_STATUS_INVALID_PARAM;
  if ((value >= (PMSM_FOC_INPUT_MIN_VALUE) ) && (value <= (PMSM_FOC_INPUT_MAX_VALUE >> 5U)))
  {
    HandlePtr->FOCInput->LPF_N_BEMF = value;
    status = PMSM_FOC_STATUS_SUCCESS;
  }
  return status;
 }

/* To set FOC MET Transition High threshold */

PMSM_FOC_STATUS_t PMSM_FOC_SetTransitionHighThreshold(PMSM_FOC_t*const HandlePtr, uint16_t value)

{
  PMSM_FOC_STATUS_t status = PMSM_FOC_STATUS_INVALID_PARAM;

  if ((value >= PMSM_FOC_INPUT_MIN_VALUE ) && (value <= PMSM_FOC_INPUT_MAX_VALUE))
  {
    HandlePtr->FOCInput->Threshold_HIGH = value;
    status = PMSM_FOC_STATUS_SUCCESS;
  }
  return status;
 }

/* To set FOC MET Transition Low threshold */

PMSM_FOC_STATUS_t PMSM_FOC_SetTransitionLowThreshold(PMSM_FOC_t*const HandlePtr, uint16_t value)

{
  PMSM_FOC_STATUS_t status = PMSM_FOC_STATUS_INVALID_PARAM;

  if ((value >= PMSM_FOC_INPUT_MIN_VALUE ) && (value <= PMSM_FOC_INPUT_MAX_VALUE))
  {
    HandlePtr->FOCInput->Threshold_LOW = value;
    status = PMSM_FOC_STATUS_SUCCESS;
  }
  return status;
 }



/* Function to check API Run time parameters limit check
 * Called by PI controller APIs of PMSM_FOC_t APP to check gain limits  */

static PMSM_FOC_STATUS_t PMSM_FOC_API_Paramter_Limit_Check(uint16_t *Kx, uint32_t value)
{
  PMSM_FOC_STATUS_t status = PMSM_FOC_STATUS_INVALID_PARAM;

  if ((value >= PMSM_FOC_API_PARAM_MIN_VALUE ) && (value <= PMSM_FOC_API_PI_MAX_VALUE))
  {
    *Kx = (uint16_t) value;
    status = PMSM_FOC_STATUS_SUCCESS;
  }
  return status;
}


/* API to set Speed PI Controller Proportional-Gain */

PMSM_FOC_STATUS_t PMSM_FOC_SetSpeedProportionalGain(PMSM_FOC_t*const HandlePtr, uint32_t kp)

{
  return PMSM_FOC_API_Paramter_Limit_Check(&(HandlePtr->PI_Speed->Kp),  kp);
}

/* API to get Speed PI Controller Proportional-Gain */

uint32_t PMSM_FOC_GetSpeedProportionalGain(PMSM_FOC_t*const HandlePtr)
{
  return (uint32_t)(HandlePtr->PI_Speed->Kp);
}

/* API to set Speed PI Controller Integral-Gain  */

PMSM_FOC_STATUS_t PMSM_FOC_SetSpeedIntegralGain (PMSM_FOC_t*const HandlePtr,uint32_t ki)

{
  return PMSM_FOC_API_Paramter_Limit_Check(&(HandlePtr->PI_Speed->Ki),  ki);
}

/* API to get Speed PI Controller Integral-Gain */

uint32_t PMSM_FOC_GetSpeedIntegralGain(PMSM_FOC_t*const HandlePtr)

{
  return (uint32_t)(HandlePtr->PI_Speed->Ki);
}

/* API to set D-axis Current or Flux PI Controller Proportional-Gain  */

PMSM_FOC_STATUS_t PMSM_FOC_SetIdProportionalGain(PMSM_FOC_t*const HandlePtr,uint32_t kp)

{

  return PMSM_FOC_API_Paramter_Limit_Check(&(HandlePtr->PI_Flux->Kp),  kp);
}

/* API to get D-axis Current or Flux PI Controller Proportional-Gain  */

uint32_t PMSM_FOC_GetIdProportionalGain(PMSM_FOC_t*const HandlePtr)
{
  return (uint32_t)(HandlePtr->PI_Flux->Kp);
}

/* API to set D-axis Current or Flux PI Controller Integral-Gain */

PMSM_FOC_STATUS_t PMSM_FOC_SetIdIntegralGain(PMSM_FOC_t*const HandlePtr,uint32_t ki)

{
  return PMSM_FOC_API_Paramter_Limit_Check(&(HandlePtr->PI_Flux->Ki),  ki);
}

/* API to get D-axis Current or Flux PI Controller Integral-Gain  */

uint32_t PMSM_FOC_GetIdIntegralGain(PMSM_FOC_t*const HandlePtr)
{
  return (uint32_t)(HandlePtr->PI_Flux->Ki);
}

/* API to set Q-axis Current or Torque PI Controller Proportional-Gain */

 PMSM_FOC_STATUS_t PMSM_FOC_SetIqProportionalGain(PMSM_FOC_t*const HandlePtr,uint32_t kp)

{
   return PMSM_FOC_API_Paramter_Limit_Check(& (HandlePtr->PI_Torque->Kp),  kp);
}

 /* API to get Q-axis Current or Torque PI Controller Proportional-Gain */

 uint32_t PMSM_FOC_GetIqProportionalGain(PMSM_FOC_t*const HandlePtr)

 {
   return (uint32_t)(HandlePtr->PI_Torque->Kp);
 }


/* API to set Q-axis Current or Torque PI Controller Integral-Gain  */

 PMSM_FOC_STATUS_t PMSM_FOC_SetIqIntegralGain(PMSM_FOC_t*const HandlePtr,uint32_t ki)

{
   return PMSM_FOC_API_Paramter_Limit_Check(&(HandlePtr->PI_Torque->Ki),  ki);

}

 /* API to get Q-axis Current or Torque PI Controller Integral-Gain  */

 uint32_t PMSM_FOC_GetIqIntegralGain(PMSM_FOC_t*const HandlePtr)
 {
   return (uint32_t)(HandlePtr->PI_Torque->Ki);
 }


 /* API to set PLL estimator PI Controller Proportional-Gain  */

 PMSM_FOC_STATUS_t PMSM_FOC_SetEstimatorProportionalGain(PMSM_FOC_t*const HandlePtr, uint32_t kp)
 {

   return PMSM_FOC_API_Paramter_Limit_Check(&(HandlePtr->PI_PLL->Kp),  kp);

 }

 /* API to get PLL estimator PI Controller Proportional-Gain  */

 uint32_t PMSM_FOC_GetEstimatorProportionalGain(PMSM_FOC_t*const HandlePtr)

 {
   return (uint32_t)(HandlePtr->PI_PLL->Kp);
 }

 /* API to set PLL Estimator PI Controller Integral-Gain  */

 PMSM_FOC_STATUS_t PMSM_FOC_SetEstimatorIntegralGain(PMSM_FOC_t*const HandlePtr,uint32_t ki)

 {
   return PMSM_FOC_API_Paramter_Limit_Check(&(HandlePtr->PI_PLL->Ki),  ki);
 }

 /* API to get PLL Estimator PI Controller Integral-Gain  */

 uint32_t PMSM_FOC_GetEstimatorIntegralGain(PMSM_FOC_t*const HandlePtr)
 {
   return (uint32_t)(HandlePtr->PI_PLL->Ki);
 }


/**
 * @endcond
 */
